#lang racket

(provide (all-defined-out))

(require srfi/13)

(define nil '())

;; string-contains-or : str, lst -> bool
(define (string-contains-or str lst)
  (cond
    [(null? lst) #f]
    [(string-contains str (car lst)) #t]
    [else (string-contains-or str (cdr lst))]))

;; string-contains-and : str, str, lst -> bool
(define (string-contains-and str str-must lst)
  (cond
    [(and (string-contains str str-must)(string-contains-or str lst)) #t]
    [else #f]))

(define (split-string str (seperator #\space))
  (define (recursive-split characters seperator (accumulator-a nil) (accumulator-b nil))
    (cond
      ((empty? characters) (reverse (map (Î» (i) (list->string i))
                                         (cons (reverse accumulator-b) accumulator-a))))
      ((char=? (car characters) seperator)
       (recursive-split (cdr characters) seperator (cons (reverse accumulator-b) accumulator-a))))))

(define (choose lst)
  (list-ref lst (random (length lst))))
 
